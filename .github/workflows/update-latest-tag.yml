name: Update 'latest' Tag

on:
  release:
    types: [ published, edited ]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Optional: source tag to point `latest` to. If empty the workflow will use the release tag (for release events) or the most recent tag.'
        required: false

permissions:
  contents: write

jobs:
  update-latest:
    runs-on: ubuntu-latest
    steps:
      - name: Update or create refs/tags/latest
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let sourceTag = '';
            if (context.eventName === 'release') {
              sourceTag = context.payload.release.tag_name;
            } else if (context.eventName === 'workflow_dispatch') {
              sourceTag = core.getInput('tag');
            }

            if (!sourceTag) {
              const tags = await github.rest.repos.listTags({ owner, repo, per_page: 1 });
              if (tags.data.length === 0) throw new Error('No tags found in the repository to use as source.');
              sourceTag = tags.data[0].name;
            }

            console.log(`Using source tag: ${sourceTag}`);

            // Resolve tag -> commit SHA
            let sha;
            try {
              const ref = await github.rest.git.getRef({ owner, repo, ref: `tags/${sourceTag}` });
              const obj = ref.data.object;
              if (obj.type === 'tag') {
                // annotated tag -> resolve to commit
                const tagObj = await github.rest.git.getTag({ owner, repo, tag_sha: obj.sha });
                sha = tagObj.data.object.sha;
              } else {
                // lightweight tag
                sha = obj.sha;
              }
            } catch (err) {
              // fallback: list tags and find commit sha
              const list = await github.rest.repos.listTags({ owner, repo, per_page: 100 });
              const found = list.data.find(t => t.name === sourceTag);
              if (!found) throw new Error(`Failed to resolve tag ${sourceTag}: ${err.message}`);
              sha = found.commit.sha;
            }

            console.log(`Resolved SHA: ${sha}`);

            // Update refs/tags/latest (force) or create if missing
            try {
              await github.rest.git.updateRef({ owner, repo, ref: 'tags/latest', sha, force: true });
              console.log('Updated refs/tags/latest');
            } catch (err) {
              await github.rest.git.createRef({ owner, repo, ref: 'refs/tags/latest', sha });
              console.log('Created refs/tags/latest');
            }

            // Confirm the refs/tags/latest points to the expected SHA and print hash
            try {
              const latestRef = await github.rest.git.getRef({ owner, repo, ref: 'tags/latest' });
              const latestSha = latestRef.data.object.sha;
              console.log(`Resolved SHA: ${sha}`);
              console.log(`refs/tags/latest now points to: ${latestSha}`);
              console.log(`refs/tags/latest short: ${latestSha.substring(0,7)}`);
            } catch (err) {
              console.log('Warning: failed to fetch refs/tags/latest after update:', err.message);
            }
